---
import BaseHead from '../../components/BaseHead.astro';
import Header from '../../components/Header.astro';
import { SITE_TITLE, SITE_DESCRIPTION } from '../../consts';
import AuthorComplement from '../../components/AuthorComplement.astro';
import Screen from '../../components/Screen.astro';
import Container from '../../components/Container.astro';
import ProgressReading from '../../components/ProgressReading.astro';
import Menu from '../../components/article-page/Menu.astro';
import ArticleFeedback from '../../components/article-page/ArticleFeedback.astro';
import AuthorInfo from '../../components/article-page/AuthorInfo.astro';
import TagsAndShare from '../../components/article-page/TagsAndShare.astro';
import Pagination from '../../components/article-page/Pagination.astro';
import Breadcrumb from '../../components/Breadcrumb.astro';
import Footer from '../../components/Footer.astro';
import NewsLetter from '../../components/NewsLetter.astro';
import fetchApi from '../../lib/strapi';
import type Article from '../../interfaces/article';
import { getStyleBackgroundImage } from '../../utils/getStyleBackgroundImage';
import ArticleContent from '../../components/article-page/ArticleContent.astro';
import { getImage } from 'astro:assets';
import { defaultBlogRequests } from '../../lib/blog';
import Comments from '../../components/react/Comments.tsx';
const email = import.meta.env.PUBLIC_EMAIL;

export const prerender = true;

export async function getStaticPaths() {
  const postData = await fetchApi<Article[]>({
    endpoint: '/articles',
    wrappedByKey: 'data',
    query: {
      fields: ['slug'],
      publicationState: 'live',
    },
  });
  return postData.map((post) => ({
    params: { slug: post.attributes.slug },
  }));
}

const { slug } = Astro.params;

const { blogInfo, footerNavigation, headerNavigation } = await defaultBlogRequests();

const postData = await fetchApi<Article>({
  endpoint: '/articles',
  wrappedByList: true,
  wrappedByKey: 'data',
  query: {
    filters: {
      slug: {
        $eq: slug,
      },
    },
    populate: {
      author: {
        fields: '*',
        populate: '*',
      },
      mainImage: '*',
      categories: '*',
      tags: '*',
      relatedArticles: '*',
    },
    publicationState: 'live',
  },
});
if (!postData || postData === undefined || !postData.id) {
  Astro.redirect('/404');
}

const prevId = postData.id === 1 ? postData.id + 2 : postData.id - 1;
const nextArticle = await fetchApi<Article | null>({
  endpoint: `/articles/${postData.id + 1}`,
  wrappedByKey: 'data',
  query: {
    fields: ['slug', 'title'],
    publicationState: 'live',
  },
});

const prevArticle = await fetchApi<Article | null>({
  endpoint: `/articles/${prevId}`,
  wrappedByKey: 'data',
  query: {
    fields: ['slug', 'title'],
    publicationState: 'live',
  },
});

const safePrevArticle = await fetchApi<Article>({
  endpoint: `/articles`,
  wrappedByKey: 'data',
  wrappedByList: true,
  query: {
    fields: ['slug', 'title'],
    publicationState: 'live',
    pagination: {
      pageSize: 1,
      page: 1,
    },
  },
});

const safeNextArticle = await fetchApi<Article>({
  endpoint: `/articles`,
  wrappedByKey: 'data',
  wrappedByList: true,
  query: {
    fields: ['slug', 'title'],
    publicationState: 'live',
    pagination: {
      pageSize: 1,
      page: 2,
    },
  },
});
const imgUrl = `${import.meta.env.NODE_ENV === 'development' ? import.meta.env.STRAPI_URL : ''}`;
const def = postData.attributes.mainImage.data
  ? await getImage({
      src: imgUrl + postData.attributes.mainImage.data.attributes.url,
      width: postData.attributes.mainImage.data.attributes.width,
      height: postData.attributes.mainImage.data.attributes.height,
      format: 'webp',
    })
  : undefined;

const categories = postData.attributes.categories.data || [];

const h1List =
  postData.attributes.content.match(/<h1>(.*?)<\/h1>/g)?.map((h1) => h1.replace(/<\/?h1>/g, '')) ??
  [];
---

<!doctype html>
<html lang="en">
  <head>
    <BaseHead title={SITE_TITLE} description={SITE_DESCRIPTION} />
  </head>
  <body>
    <Header blogInfo={blogInfo} headerNavigation={headerNavigation} />
    <Screen
      class="h-[424px] lg:h-[481px] justify-end relative"
      style={getStyleBackgroundImage(def?.src)}
    >
      <Container class={'flex-col gap-32 lg:gap-64 pb-32 pt-80 lg:py-80'}>
        <div></div>
        <h1 class="font-semibold text-white text-center w-full">
          {postData.attributes.title}
        </h1>
        <AuthorComplement
          author={postData.attributes.author.data}
          date={postData.attributes.createdAt}
          readingTime={postData.attributes.readingTime}
        />
      </Container>
    </Screen>

    <div class="relative w-full lg:py-80">
      <ProgressReading />
      <Breadcrumb
        class={'flex lg:hidden py-16 px-[36px]'}
        items={[
          categories?.map((category) => ({
            title: category.attributes.title,
            url: `/c/${category.attributes.slug}`,
          })),
          { title: postData.attributes.title, url: postData.attributes.slug },
        ]}
      />
      <Screen class="pl-0 relative pr-24 py-32 lg:py-0 justify-end">
        <Container class={'gap-24 lg:gap-64 '}>
          <Menu
            email={email}
            titles={h1List}
            idArticle={postData.id}
            likes={postData.attributes.likes}
            url={postData.attributes.slug}
          />
          <div class="flex flex-col gap-32 items-start flex-1 overflow-visible">
            <Breadcrumb
              class={'hidden lg:flex'}
              items={[
                categories?.map((category) => ({
                  title: category.attributes.title,
                  url: `/c/${category.attributes.slug}`,
                })),
                { title: postData.attributes.title, url: postData.attributes.slug },
              ]}
            />
            <ArticleContent content={postData.attributes.content} />
            <div class="flex flex-col gap-32 items-start flex-1 overflow-hidden">
              <ArticleFeedback id={postData.id} usefullCount={postData.attributes.usefullCount} />
              <Pagination
                nextArticle={nextArticle ?? safeNextArticle}
                prevArticle={prevArticle ?? safePrevArticle}
              />
              {
                postData.attributes.author.data && (
                  <AuthorInfo author={postData.attributes.author.data} />
                )
              }
              <TagsAndShare tags={postData.attributes.tags.data} slug={postData.attributes.slug} />
              <Comments client:visible id={postData.id} />
            </div>
          </div>
        </Container>
      </Screen>
    </div>
    <NewsLetter />
    <Footer footerNavigation={footerNavigation} blogInfo={blogInfo} />
  </body>
</html>
